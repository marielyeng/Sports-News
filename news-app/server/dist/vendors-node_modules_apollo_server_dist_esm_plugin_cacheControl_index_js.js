"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_apollo_server_dist_esm_plugin_cacheControl_index_js";
exports.ids = ["vendors-node_modules_apollo_server_dist_esm_plugin_cacheControl_index_js"];
exports.modules = {

/***/ "../../node_modules/@apollo/server/dist/esm/plugin/cacheControl/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@apollo/server/dist/esm/plugin/cacheControl/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApolloServerPluginCacheControl: () => (/* binding */ ApolloServerPluginCacheControl)\n/* harmony export */ });\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphql */ \"../../node_modules/graphql/type/definition.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! graphql */ \"../../node_modules/graphql/jsutils/Path.mjs\");\n/* harmony import */ var _cachePolicy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../cachePolicy.js */ \"../../node_modules/@apollo/server/dist/esm/cachePolicy.js\");\n/* harmony import */ var _internalPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../internalPlugin.js */ \"../../node_modules/@apollo/server/dist/esm/internalPlugin.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lru-cache */ \"../../node_modules/lru-cache/index.mjs\");\n\n\n\n\nfunction ApolloServerPluginCacheControl(options = Object.create(null)) {\n    let typeAnnotationCache;\n    let fieldAnnotationCache;\n    return (0,_internalPlugin_js__WEBPACK_IMPORTED_MODULE_1__.internalPlugin)({\n        __internal_plugin_id__: 'CacheControl',\n        __is_disabled_plugin__: false,\n        async serverWillStart({ schema }) {\n            typeAnnotationCache = new lru_cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                max: Object.values(schema.getTypeMap()).filter(graphql__WEBPACK_IMPORTED_MODULE_3__.isCompositeType)\n                    .length,\n            });\n            fieldAnnotationCache = new lru_cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                max: Object.values(schema.getTypeMap())\n                    .filter(graphql__WEBPACK_IMPORTED_MODULE_3__.isObjectType)\n                    .flatMap((t) => Object.values(t.getFields())).length +\n                    Object.values(schema.getTypeMap())\n                        .filter(graphql__WEBPACK_IMPORTED_MODULE_3__.isInterfaceType)\n                        .flatMap((t) => Object.values(t.getFields())).length,\n            });\n            return undefined;\n        },\n        async requestDidStart(requestContext) {\n            function memoizedCacheAnnotationFromType(t) {\n                const existing = typeAnnotationCache.get(t);\n                if (existing) {\n                    return existing;\n                }\n                const annotation = cacheAnnotationFromType(t);\n                typeAnnotationCache.set(t, annotation);\n                return annotation;\n            }\n            function memoizedCacheAnnotationFromField(field) {\n                const existing = fieldAnnotationCache.get(field);\n                if (existing) {\n                    return existing;\n                }\n                const annotation = cacheAnnotationFromField(field);\n                fieldAnnotationCache.set(field, annotation);\n                return annotation;\n            }\n            const defaultMaxAge = options.defaultMaxAge ?? 0;\n            const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n            const { __testing__cacheHints } = options;\n            return {\n                async executionDidStart() {\n                    if (isRestricted(requestContext.overallCachePolicy)) {\n                        const fakeFieldPolicy = (0,_cachePolicy_js__WEBPACK_IMPORTED_MODULE_0__.newCachePolicy)();\n                        return {\n                            willResolveField({ info }) {\n                                info.cacheControl = {\n                                    setCacheHint: (dynamicHint) => {\n                                        fakeFieldPolicy.replace(dynamicHint);\n                                    },\n                                    cacheHint: fakeFieldPolicy,\n                                    cacheHintFromType: memoizedCacheAnnotationFromType,\n                                };\n                            },\n                        };\n                    }\n                    return {\n                        willResolveField({ info }) {\n                            const fieldPolicy = (0,_cachePolicy_js__WEBPACK_IMPORTED_MODULE_0__.newCachePolicy)();\n                            let inheritMaxAge = false;\n                            const targetType = (0,graphql__WEBPACK_IMPORTED_MODULE_3__.getNamedType)(info.returnType);\n                            if ((0,graphql__WEBPACK_IMPORTED_MODULE_3__.isCompositeType)(targetType)) {\n                                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);\n                                fieldPolicy.replace(typeAnnotation);\n                                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n                            }\n                            const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);\n                            if (fieldAnnotation.inheritMaxAge &&\n                                fieldPolicy.maxAge === undefined) {\n                                inheritMaxAge = true;\n                                if (fieldAnnotation.scope) {\n                                    fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                                }\n                            }\n                            else {\n                                fieldPolicy.replace(fieldAnnotation);\n                            }\n                            info.cacheControl = {\n                                setCacheHint: (dynamicHint) => {\n                                    fieldPolicy.replace(dynamicHint);\n                                },\n                                cacheHint: fieldPolicy,\n                                cacheHintFromType: memoizedCacheAnnotationFromType,\n                            };\n                            return () => {\n                                if (fieldPolicy.maxAge === undefined &&\n                                    (((0,graphql__WEBPACK_IMPORTED_MODULE_3__.isCompositeType)(targetType) && !inheritMaxAge) ||\n                                        !info.path.prev)) {\n                                    fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                                }\n                                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                                    const path = (0,graphql__WEBPACK_IMPORTED_MODULE_4__.pathToArray)(info.path).join('.');\n                                    if (__testing__cacheHints.has(path)) {\n                                        throw Error(\"shouldn't happen: addHint should only be called once per path\");\n                                    }\n                                    __testing__cacheHints.set(path, {\n                                        maxAge: fieldPolicy.maxAge,\n                                        scope: fieldPolicy.scope,\n                                    });\n                                }\n                                requestContext.overallCachePolicy.restrict(fieldPolicy);\n                            };\n                        },\n                    };\n                },\n                async willSendResponse(requestContext) {\n                    if (!calculateHttpHeaders) {\n                        return;\n                    }\n                    const { response, overallCachePolicy } = requestContext;\n                    const existingCacheControlHeader = parseExistingCacheControlHeader(response.http.headers.get('cache-control'));\n                    if (existingCacheControlHeader.kind === 'unparsable') {\n                        return;\n                    }\n                    const cachePolicy = (0,_cachePolicy_js__WEBPACK_IMPORTED_MODULE_0__.newCachePolicy)();\n                    cachePolicy.replace(overallCachePolicy);\n                    if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {\n                        cachePolicy.restrict(existingCacheControlHeader.hint);\n                    }\n                    const policyIfCacheable = cachePolicy.policyIfCacheable();\n                    if (policyIfCacheable &&\n                        existingCacheControlHeader.kind !== 'uncacheable' &&\n                        response.body.kind === 'single' &&\n                        !response.body.singleResult.errors) {\n                        response.http.headers.set('cache-control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);\n                    }\n                    else if (calculateHttpHeaders !== 'if-cacheable') {\n                        response.http.headers.set('cache-control', CACHE_CONTROL_HEADER_UNCACHEABLE);\n                    }\n                },\n            };\n        },\n    });\n}\nconst CACHE_CONTROL_HEADER_CACHEABLE_REGEXP = /^max-age=(\\d+), (public|private)$/;\nconst CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';\nfunction parseExistingCacheControlHeader(header) {\n    if (!header) {\n        return { kind: 'no-header' };\n    }\n    if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {\n        return { kind: 'uncacheable' };\n    }\n    const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);\n    if (!match) {\n        return { kind: 'unparsable' };\n    }\n    return {\n        kind: 'parsable-and-cacheable',\n        hint: {\n            maxAge: +match[1],\n            scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',\n        },\n    };\n}\nfunction cacheAnnotationFromDirectives(directives) {\n    if (!directives)\n        return undefined;\n    const cacheControlDirective = directives.find((directive) => directive.name.value === 'cacheControl');\n    if (!cacheControlDirective)\n        return undefined;\n    if (!cacheControlDirective.arguments)\n        return undefined;\n    const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'maxAge');\n    const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'scope');\n    const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'inheritMaxAge');\n    const scopeString = scopeArgument?.value?.kind === 'EnumValue'\n        ? scopeArgument.value.value\n        : undefined;\n    const scope = scopeString === 'PUBLIC' || scopeString === 'PRIVATE'\n        ? scopeString\n        : undefined;\n    if (inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n        inheritMaxAgeArgument.value.value) {\n        return { inheritMaxAge: true, scope };\n    }\n    return {\n        maxAge: maxAgeArgument?.value?.kind === 'IntValue'\n            ? parseInt(maxAgeArgument.value.value)\n            : undefined,\n        scope,\n    };\n}\nfunction cacheAnnotationFromType(t) {\n    if (t.astNode) {\n        const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n        if (hint) {\n            return hint;\n        }\n    }\n    if (t.extensionASTNodes) {\n        for (const node of t.extensionASTNodes) {\n            const hint = cacheAnnotationFromDirectives(node.directives);\n            if (hint) {\n                return hint;\n            }\n        }\n    }\n    return {};\n}\nfunction cacheAnnotationFromField(field) {\n    if (field.astNode) {\n        const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n        if (hint) {\n            return hint;\n        }\n    }\n    return {};\n}\nfunction isRestricted(hint) {\n    return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://server/../../node_modules/@apollo/server/dist/esm/plugin/cacheControl/index.js?");

/***/ })

};
;